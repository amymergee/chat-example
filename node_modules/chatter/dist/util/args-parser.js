'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.parseArgs = parseArgs;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse args from an array or string. Suitable for use with lines of chat.
//
// Example:
// parseArgs(`foo 'bar baz' a=123 b="x y z = 456" "can't wait"`, {aaa: Number, bbb: String})
// Returns:
// { options: { aaa: 123, bbb: 'x y z = 456' },
//   args: [ 'foo', 'bar baz', 'can\'t wait' ],
//   errors: [] }
function parseArgs(args) {
  var validProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var options = {};
  var remain = [];
  var errors = [];

  if (typeof args === 'string') {
    args = args.split(' ');
  }
  // Use a copy so the originally passed args array isn't modified.
  else {
      args = [].concat((0, _toConsumableArray3.default)(args));
    }

  function setOption(arg) {
    // Anything before the first = is the prop name, the rest is the value.
    var _ref = arg.match(/([^=]+)=(.*)/) || [],
        _ref2 = (0, _slicedToArray3.default)(_ref, 3),
        prop = _ref2[1],
        value = _ref2[2];

    if (!prop && !value) {
      return false;
    }
    // Matches are case insensitive, and can be an abbreviation of the actual
    // prop name.
    var matches = (0, _keys2.default)(validProps).filter(function (p) {
      return p.toLowerCase().indexOf(prop.toLowerCase()) === 0;
    });
    if (matches.length === 1) {
      var _matches = (0, _slicedToArray3.default)(matches, 1),
          match = _matches[0];
      // Sanitize/coerce value with the specified function.


      options[match] = validProps[match](value);
    } else if (matches.length > 1) {
      errors.push('Ambiguous option "' + prop + '" specified (matches: ' + matches.join(', ') + ').');
    } else {
      errors.push('Unknown option "' + prop + '" specified.');
    }
    return true;
  }

  while (args.length > 0) {
    // Match arg starting with ' or " or containing =' or ="
    var _ref3 = args[0].match(/(^|=)(['"])/) || [],
        equals = _ref3[1],
        quote = _ref3[2],
        eqIndex = _ref3.index;

    var arg = void 0;
    // Arg contained a quote.
    if (quote) {
      (function () {
        // Find arg ending with matching quote. Don't look at the matched quote
        // part for the first argument.
        var re = new RegExp(quote + '$');
        var offset = eqIndex + equals.length + 1;
        var endIndex = args.findIndex(function (a, i) {
          return re.test(i === 0 ? a.slice(offset) : a);
        });
        // Matching arg was found.
        if (endIndex !== -1) {
          // Join all args between and including the start and end arg on space,
          // then remove trailing quote char.
          arg = args.splice(0, endIndex + 1).join(' ').slice(0, -1);
          // Remove starting quote char.
          arg = equals ? arg.slice(0, eqIndex + 1) + arg.slice(eqIndex + 2) : arg.slice(1);
        }
      })();
    }
    // If no quoted arg was found, use the next arg.
    if (!arg) {
      arg = args.shift();
    }
    // If arg is an a=b style option, parse it. If it's an empty string, ignore
    // it. Otherwise add it to the remain array.
    if (!setOption(arg) && arg) {
      remain.push(arg);
    }
  }

  return {
    options: options,
    args: remain,
    errors: errors
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2FyZ3MtcGFyc2VyLmpzIl0sIm5hbWVzIjpbInBhcnNlQXJncyIsImFyZ3MiLCJ2YWxpZFByb3BzIiwib3B0aW9ucyIsInJlbWFpbiIsImVycm9ycyIsInNwbGl0Iiwic2V0T3B0aW9uIiwiYXJnIiwibWF0Y2giLCJwcm9wIiwidmFsdWUiLCJtYXRjaGVzIiwiZmlsdGVyIiwicCIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsImxlbmd0aCIsInB1c2giLCJqb2luIiwiZXF1YWxzIiwicXVvdGUiLCJlcUluZGV4IiwiaW5kZXgiLCJyZSIsIlJlZ0V4cCIsIm9mZnNldCIsImVuZEluZGV4IiwiZmluZEluZGV4IiwiYSIsImkiLCJ0ZXN0Iiwic2xpY2UiLCJzcGxpY2UiLCJzaGlmdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBUWdCQSxTLEdBQUFBLFM7Ozs7QUFSaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLFNBQVQsQ0FBbUJDLElBQW5CLEVBQTBDO0FBQUEsTUFBakJDLFVBQWlCLHVFQUFKLEVBQUk7O0FBQy9DLE1BQU1DLFVBQVUsRUFBaEI7QUFDQSxNQUFNQyxTQUFTLEVBQWY7QUFDQSxNQUFNQyxTQUFTLEVBQWY7O0FBRUEsTUFBSSxPQUFPSixJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCQSxXQUFPQSxLQUFLSyxLQUFMLENBQVcsR0FBWCxDQUFQO0FBQ0Q7QUFDRDtBQUhBLE9BSUs7QUFDSEwsd0RBQVdBLElBQVg7QUFDRDs7QUFFRCxXQUFTTSxTQUFULENBQW1CQyxHQUFuQixFQUF3QjtBQUN0QjtBQURzQixlQUVFQSxJQUFJQyxLQUFKLENBQVUsY0FBVixLQUE2QixFQUYvQjtBQUFBO0FBQUEsUUFFYkMsSUFGYTtBQUFBLFFBRVBDLEtBRk87O0FBR3RCLFFBQUksQ0FBQ0QsSUFBRCxJQUFTLENBQUNDLEtBQWQsRUFBcUI7QUFDbkIsYUFBTyxLQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsUUFBTUMsVUFBVSxvQkFBWVYsVUFBWixFQUF3QlcsTUFBeEIsQ0FBK0I7QUFBQSxhQUFLQyxFQUFFQyxXQUFGLEdBQWdCQyxPQUFoQixDQUF3Qk4sS0FBS0ssV0FBTCxFQUF4QixNQUFnRCxDQUFyRDtBQUFBLEtBQS9CLENBQWhCO0FBQ0EsUUFBSUgsUUFBUUssTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUFBLGtEQUNSTCxPQURRO0FBQUEsVUFDakJILEtBRGlCO0FBRXhCOzs7QUFDQU4sY0FBUU0sS0FBUixJQUFpQlAsV0FBV08sS0FBWCxFQUFrQkUsS0FBbEIsQ0FBakI7QUFDRCxLQUpELE1BS0ssSUFBSUMsUUFBUUssTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUMzQlosYUFBT2EsSUFBUCx3QkFBaUNSLElBQWpDLDhCQUE4REUsUUFBUU8sSUFBUixDQUFhLElBQWIsQ0FBOUQ7QUFDRCxLQUZJLE1BR0E7QUFDSGQsYUFBT2EsSUFBUCxzQkFBK0JSLElBQS9CO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPVCxLQUFLZ0IsTUFBTCxHQUFjLENBQXJCLEVBQXdCO0FBQ3RCO0FBRHNCLGdCQUV3QmhCLEtBQUssQ0FBTCxFQUFRUSxLQUFSLENBQWMsYUFBZCxLQUFnQyxFQUZ4RDtBQUFBLFFBRVpXLE1BRlksU0FFZixDQUZlO0FBQUEsUUFFREMsS0FGQyxTQUVKLENBRkk7QUFBQSxRQUVhQyxPQUZiLFNBRU1DLEtBRk47O0FBR3RCLFFBQUlmLFlBQUo7QUFDQTtBQUNBLFFBQUlhLEtBQUosRUFBVztBQUFBO0FBQ1Q7QUFDQTtBQUNBLFlBQU1HLEtBQUssSUFBSUMsTUFBSixDQUFXSixRQUFRLEdBQW5CLENBQVg7QUFDQSxZQUFNSyxTQUFTSixVQUFVRixPQUFPSCxNQUFqQixHQUEwQixDQUF6QztBQUNBLFlBQU1VLFdBQVcxQixLQUFLMkIsU0FBTCxDQUFlLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGlCQUFVTixHQUFHTyxJQUFILENBQVFELE1BQU0sQ0FBTixHQUFVRCxFQUFFRyxLQUFGLENBQVFOLE1BQVIsQ0FBVixHQUE0QkcsQ0FBcEMsQ0FBVjtBQUFBLFNBQWYsQ0FBakI7QUFDQTtBQUNBLFlBQUlGLGFBQWEsQ0FBQyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBO0FBQ0FuQixnQkFBTVAsS0FBS2dDLE1BQUwsQ0FBWSxDQUFaLEVBQWVOLFdBQVcsQ0FBMUIsRUFBNkJSLElBQTdCLENBQWtDLEdBQWxDLEVBQXVDYSxLQUF2QyxDQUE2QyxDQUE3QyxFQUFnRCxDQUFDLENBQWpELENBQU47QUFDQTtBQUNBeEIsZ0JBQU1ZLFNBQVNaLElBQUl3QixLQUFKLENBQVUsQ0FBVixFQUFhVixVQUFVLENBQXZCLElBQTRCZCxJQUFJd0IsS0FBSixDQUFVVixVQUFVLENBQXBCLENBQXJDLEdBQThEZCxJQUFJd0IsS0FBSixDQUFVLENBQVYsQ0FBcEU7QUFDRDtBQWJRO0FBY1Y7QUFDRDtBQUNBLFFBQUksQ0FBQ3hCLEdBQUwsRUFBVTtBQUNSQSxZQUFNUCxLQUFLaUMsS0FBTCxFQUFOO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsUUFBSSxDQUFDM0IsVUFBVUMsR0FBVixDQUFELElBQW1CQSxHQUF2QixFQUE0QjtBQUMxQkosYUFBT2MsSUFBUCxDQUFZVixHQUFaO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPO0FBQ0xMLG9CQURLO0FBRUxGLFVBQU1HLE1BRkQ7QUFHTEM7QUFISyxHQUFQO0FBS0QiLCJmaWxlIjoiYXJncy1wYXJzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYXJzZSBhcmdzIGZyb20gYW4gYXJyYXkgb3Igc3RyaW5nLiBTdWl0YWJsZSBmb3IgdXNlIHdpdGggbGluZXMgb2YgY2hhdC5cbi8vXG4vLyBFeGFtcGxlOlxuLy8gcGFyc2VBcmdzKGBmb28gJ2JhciBiYXonIGE9MTIzIGI9XCJ4IHkgeiA9IDQ1NlwiIFwiY2FuJ3Qgd2FpdFwiYCwge2FhYTogTnVtYmVyLCBiYmI6IFN0cmluZ30pXG4vLyBSZXR1cm5zOlxuLy8geyBvcHRpb25zOiB7IGFhYTogMTIzLCBiYmI6ICd4IHkgeiA9IDQ1NicgfSxcbi8vICAgYXJnczogWyAnZm9vJywgJ2JhciBiYXonLCAnY2FuXFwndCB3YWl0JyBdLFxuLy8gICBlcnJvcnM6IFtdIH1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJncywgdmFsaWRQcm9wcyA9IHt9KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgY29uc3QgcmVtYWluID0gW107XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmdzID0gYXJncy5zcGxpdCgnICcpO1xuICB9XG4gIC8vIFVzZSBhIGNvcHkgc28gdGhlIG9yaWdpbmFsbHkgcGFzc2VkIGFyZ3MgYXJyYXkgaXNuJ3QgbW9kaWZpZWQuXG4gIGVsc2Uge1xuICAgIGFyZ3MgPSBbLi4uYXJnc107XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPcHRpb24oYXJnKSB7XG4gICAgLy8gQW55dGhpbmcgYmVmb3JlIHRoZSBmaXJzdCA9IGlzIHRoZSBwcm9wIG5hbWUsIHRoZSByZXN0IGlzIHRoZSB2YWx1ZS5cbiAgICBjb25zdCBbLCBwcm9wLCB2YWx1ZV0gPSBhcmcubWF0Y2goLyhbXj1dKyk9KC4qKS8pIHx8IFtdO1xuICAgIGlmICghcHJvcCAmJiAhdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGNhbiBiZSBhbiBhYmJyZXZpYXRpb24gb2YgdGhlIGFjdHVhbFxuICAgIC8vIHByb3AgbmFtZS5cbiAgICBjb25zdCBtYXRjaGVzID0gT2JqZWN0LmtleXModmFsaWRQcm9wcykuZmlsdGVyKHAgPT4gcC50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJvcC50b0xvd2VyQ2FzZSgpKSA9PT0gMCk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBbbWF0Y2hdID0gbWF0Y2hlcztcbiAgICAgIC8vIFNhbml0aXplL2NvZXJjZSB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAgICBvcHRpb25zW21hdGNoXSA9IHZhbGlkUHJvcHNbbWF0Y2hdKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcnMucHVzaChgQW1iaWd1b3VzIG9wdGlvbiBcIiR7cHJvcH1cIiBzcGVjaWZpZWQgKG1hdGNoZXM6ICR7bWF0Y2hlcy5qb2luKCcsICcpfSkuYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goYFVua25vd24gb3B0aW9uIFwiJHtwcm9wfVwiIHNwZWNpZmllZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB3aGlsZSAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gTWF0Y2ggYXJnIHN0YXJ0aW5nIHdpdGggJyBvciBcIiBvciBjb250YWluaW5nID0nIG9yID1cIlxuICAgIGNvbnN0IHsxOiBlcXVhbHMsIDI6IHF1b3RlLCBpbmRleDogZXFJbmRleH0gPSBhcmdzWzBdLm1hdGNoKC8oXnw9KShbJ1wiXSkvKSB8fCBbXTtcbiAgICBsZXQgYXJnO1xuICAgIC8vIEFyZyBjb250YWluZWQgYSBxdW90ZS5cbiAgICBpZiAocXVvdGUpIHtcbiAgICAgIC8vIEZpbmQgYXJnIGVuZGluZyB3aXRoIG1hdGNoaW5nIHF1b3RlLiBEb24ndCBsb29rIGF0IHRoZSBtYXRjaGVkIHF1b3RlXG4gICAgICAvLyBwYXJ0IGZvciB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAocXVvdGUgKyAnJCcpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZXFJbmRleCArIGVxdWFscy5sZW5ndGggKyAxO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBhcmdzLmZpbmRJbmRleCgoYSwgaSkgPT4gcmUudGVzdChpID09PSAwID8gYS5zbGljZShvZmZzZXQpIDogYSkpO1xuICAgICAgLy8gTWF0Y2hpbmcgYXJnIHdhcyBmb3VuZC5cbiAgICAgIGlmIChlbmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgLy8gSm9pbiBhbGwgYXJncyBiZXR3ZWVuIGFuZCBpbmNsdWRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgYXJnIG9uIHNwYWNlLFxuICAgICAgICAvLyB0aGVuIHJlbW92ZSB0cmFpbGluZyBxdW90ZSBjaGFyLlxuICAgICAgICBhcmcgPSBhcmdzLnNwbGljZSgwLCBlbmRJbmRleCArIDEpLmpvaW4oJyAnKS5zbGljZSgwLCAtMSk7XG4gICAgICAgIC8vIFJlbW92ZSBzdGFydGluZyBxdW90ZSBjaGFyLlxuICAgICAgICBhcmcgPSBlcXVhbHMgPyBhcmcuc2xpY2UoMCwgZXFJbmRleCArIDEpICsgYXJnLnNsaWNlKGVxSW5kZXggKyAyKSA6IGFyZy5zbGljZSgxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbm8gcXVvdGVkIGFyZyB3YXMgZm91bmQsIHVzZSB0aGUgbmV4dCBhcmcuXG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIGFyZyA9IGFyZ3Muc2hpZnQoKTtcbiAgICB9XG4gICAgLy8gSWYgYXJnIGlzIGFuIGE9YiBzdHlsZSBvcHRpb24sIHBhcnNlIGl0LiBJZiBpdCdzIGFuIGVtcHR5IHN0cmluZywgaWdub3JlXG4gICAgLy8gaXQuIE90aGVyd2lzZSBhZGQgaXQgdG8gdGhlIHJlbWFpbiBhcnJheS5cbiAgICBpZiAoIXNldE9wdGlvbihhcmcpICYmIGFyZykge1xuICAgICAgcmVtYWluLnB1c2goYXJnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgYXJnczogcmVtYWluLFxuICAgIGVycm9ycyxcbiAgfTtcbn1cbiJdfQ==

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bot = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

exports.default = createBot;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _botHelpers = require('./util/bot-helpers');

var _processMessage2 = require('./util/process-message');

var _response = require('./util/response');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Bot = exports.Bot = function () {
  function Bot() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Bot);
    var createMessageHandler = options.createMessageHandler,
        verbose = options.verbose;

    if (!createMessageHandler) {
      throw new TypeError('Missing required "createMessageHandler" option.');
    }
    this.createMessageHandler = createMessageHandler;
    // Log more?
    this.verbose = verbose;
    // Cache of message handlers.
    this.handlerCache = {};
    // Allow any of these options to override default Bot methods.
    (0, _botHelpers.overrideProperties)(this, options, ['formatErrorMessage', 'log', 'logError', 'onMessage', 'ignoreMessage', 'getMessageHandlerCacheId', 'getMessageHandler', 'getMessageHandlerArgs', 'handleResponse', 'handleError', 'sendResponse']);
  }

  // Expose the processMessage function on Bot instances for convenience.


  (0, _createClass3.default)(Bot, [{
    key: 'processMessage',
    value: function processMessage() {
      return _processMessage2.processMessage.apply(undefined, arguments);
    }

    // String formatting helper functions.

  }, {
    key: 'formatErrorMessage',
    value: function formatErrorMessage(message) {
      return 'An error occurred: ' + message;
    }

    // Overridable logger.

  }, {
    key: 'log',
    value: function log() {
      var _console;

      (_console = console).log.apply(_console, arguments);
    }

    // Overridable error logger.

  }, {
    key: 'logError',
    value: function logError() {
      var _console2;

      (_console2 = console).error.apply(_console2, arguments);
    }

    // This is main "run loop" for the bot. When a message is received, it gets
    // passed into this function to be handled.

  }, {
    key: 'onMessage',
    value: function onMessage(message) {
      var _this = this;

      return _bluebird2.default.try(function () {
        // Get the message text and an optional array of arguments based on the
        // current message. This is especially useful when "message" is an object,
        // and not a text string.
        var messageHandlerArgs = _this.getMessageHandlerArgs(message);
        // Abort if false was returned. This gives the getMessageHandlerArg
        // function the ability to pre-emptively ignore messages.
        if (messageHandlerArgs === false) {
          return [false];
        }
        var text = messageHandlerArgs.text,
            _messageHandlerArgs$a = messageHandlerArgs.args,
            args = _messageHandlerArgs$a === undefined ? [message] : _messageHandlerArgs$a;
        // Get the id to retrieve a stateful message handler from the cache.

        var id = _this.getMessageHandlerCacheId.apply(_this, (0, _toConsumableArray3.default)(args));
        // Get a cached message handler via its id, or call createMessageHandler
        // to create a new one.
        var messageHandler = _this.getMessageHandler.apply(_this, [id].concat((0, _toConsumableArray3.default)(args)));
        return [messageHandler, text, args];
      }).spread(function (messageHandler, text, args) {
        // If messageHandlerArgs or getMessageHandler returned false, abort.
        if (messageHandler === false) {
          return false;
        }
        // Process text and additional args through the message handler.
        return _this.processMessage.apply(_this, [messageHandler, text].concat((0, _toConsumableArray3.default)(args)))
        // Then handle the response.
        .then(function (response) {
          return _this.handleResponse(message, response);
        });
      })
      // If there was an error, handle that.
      .catch(function (error) {
        return _this.handleError(message, error);
      });
    }

    // Return an object that defines the message text and any additional arguments
    // to be passed into message handlers (and the getMessageHandlerCacheId and
    // getMessageHandler functions).
    //
    // This function receives the "message" value passed into onMessage.
    //
    // By default, Bot expect "message" to be an object with, at the minimum, a
    // "text" property. If your message is in a different format, override this
    // function. Eg. If messages are just strings of text, return {text: message}.

  }, {
    key: 'getMessageHandlerArgs',
    value: function getMessageHandlerArgs(message) {
      return {
        text: message.text,
        args: [message]
      };
    }

    // Return a value that will be used as an id to cache stateful message
    // handlers returned from the getMessageHandler function.
    //
    // This function receives the "args" returned from getMessageHandlerArgs.
    //
    // By default, Bot expects "message" to be an object with an "id" property. If
    // your message is in a different format, override this function.

  }, {
    key: 'getMessageHandlerCacheId',
    value: function getMessageHandlerCacheId(message) {
      return message && message.id;
    }

    // Return a message handler, either from cache (if it exists) or created by
    // the createMessageHandler function. If the message handler is stateful (ie.
    // has a true "hasState" property) store it in the cache for later retrieval.
    //
    // This function receives the "args" returned from getMessageHandlerArgs.

  }, {
    key: 'getMessageHandler',
    value: function getMessageHandler(id) {
      if (this.handlerCache[id]) {
        return this.handlerCache[id];
      }

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var messageHandler = this.createMessageHandler.apply(this, [id].concat(args));
      if (!messageHandler) {
        return false;
      }
      if (messageHandler.hasState) {
        this.handlerCache[id] = messageHandler;
      }
      return messageHandler;
    }

    // If a message handler didn't throw an exception and wasn't rejected, run
    // this function.
    //
    // This function receives the original "message" and "response" value returned
    // or yielded by the message handler. Normalize the response into an array
    // containing zero or more messages, and pass each to the sendResponse method,
    // in order.

  }, {
    key: 'handleResponse',
    value: function handleResponse(message, response) {
      var _this2 = this;

      if (response === false) {
        return false;
      }
      var responses = (0, _response.normalizeResponse)(response) || [];
      return _bluebird2.default.all(responses.map(function (text) {
        return _this2.sendResponse(message, text);
      }));
    }

    // If a message handler threw an exception or was otherwise rejected, run this
    // function.
    //
    // This function receives the original "message" and error object. Show the
    // error message in the same channel, group or DM from which the message
    // originated, and optionally log the error stack.

  }, {
    key: 'handleError',
    value: function handleError(message, error) {
      if (this.verbose) {
        this.logError(error.stack);
      }
      return this.sendResponse(message, this.formatErrorMessage(error.message));
    }

    // Once the response (successful or not) has been handled, this message does
    // the actual "sending" of the response back to the chat service. Which means
    // it needs to be overridden. If not, it will just log to the console.
    //
    // This function receives the original "message" and the normalized message
    // or formatted error message as the "text" value.
    //
    // If sending the response runs asynchronously, this function should return a
    // promise that is resolved when the response has been sent.

  }, {
    key: 'sendResponse',
    value: function sendResponse(message, text) {
      this.log('sendResponse', text);
    }
  }]);
  return Bot;
}();

function createBot(options) {
  return new Bot(options);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ib3QuanMiXSwibmFtZXMiOlsiY3JlYXRlQm90IiwiQm90Iiwib3B0aW9ucyIsImNyZWF0ZU1lc3NhZ2VIYW5kbGVyIiwidmVyYm9zZSIsIlR5cGVFcnJvciIsImhhbmRsZXJDYWNoZSIsIm1lc3NhZ2UiLCJsb2ciLCJlcnJvciIsInRyeSIsIm1lc3NhZ2VIYW5kbGVyQXJncyIsImdldE1lc3NhZ2VIYW5kbGVyQXJncyIsInRleHQiLCJhcmdzIiwiaWQiLCJnZXRNZXNzYWdlSGFuZGxlckNhY2hlSWQiLCJtZXNzYWdlSGFuZGxlciIsImdldE1lc3NhZ2VIYW5kbGVyIiwic3ByZWFkIiwicHJvY2Vzc01lc3NhZ2UiLCJ0aGVuIiwiaGFuZGxlUmVzcG9uc2UiLCJyZXNwb25zZSIsImNhdGNoIiwiaGFuZGxlRXJyb3IiLCJoYXNTdGF0ZSIsInJlc3BvbnNlcyIsImFsbCIsIm1hcCIsInNlbmRSZXNwb25zZSIsImxvZ0Vycm9yIiwic3RhY2siLCJmb3JtYXRFcnJvck1lc3NhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBK0t3QkEsUzs7QUEvS3hCOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7SUFFYUMsRyxXQUFBQSxHO0FBRVgsaUJBQTBCO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7QUFBQSxRQUNqQkMsb0JBRGlCLEdBQ2dCRCxPQURoQixDQUNqQkMsb0JBRGlCO0FBQUEsUUFDS0MsT0FETCxHQUNnQkYsT0FEaEIsQ0FDS0UsT0FETDs7QUFFeEIsUUFBSSxDQUFDRCxvQkFBTCxFQUEyQjtBQUN6QixZQUFNLElBQUlFLFNBQUosQ0FBYyxpREFBZCxDQUFOO0FBQ0Q7QUFDRCxTQUFLRixvQkFBTCxHQUE0QkEsb0JBQTVCO0FBQ0E7QUFDQSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQTtBQUNBLFNBQUtFLFlBQUwsR0FBb0IsRUFBcEI7QUFDQTtBQUNBLHdDQUFtQixJQUFuQixFQUF5QkosT0FBekIsRUFBa0MsQ0FDaEMsb0JBRGdDLEVBRWhDLEtBRmdDLEVBR2hDLFVBSGdDLEVBSWhDLFdBSmdDLEVBS2hDLGVBTGdDLEVBTWhDLDBCQU5nQyxFQU9oQyxtQkFQZ0MsRUFRaEMsdUJBUmdDLEVBU2hDLGdCQVRnQyxFQVVoQyxhQVZnQyxFQVdoQyxjQVhnQyxDQUFsQztBQWFEOztBQUVEOzs7OztxQ0FDd0I7QUFDdEIsYUFBTywyREFBUDtBQUNEOztBQUVEOzs7O3VDQUNtQkssTyxFQUFTO0FBQUUscUNBQTZCQSxPQUE3QjtBQUF5Qzs7QUFFdkU7Ozs7MEJBQ2E7QUFBQTs7QUFDWCwyQkFBUUMsR0FBUjtBQUNEOztBQUVEOzs7OytCQUNrQjtBQUFBOztBQUNoQiw0QkFBUUMsS0FBUjtBQUNEOztBQUVEO0FBQ0E7Ozs7OEJBQ1VGLE8sRUFBUztBQUFBOztBQUNqQixhQUFPLG1CQUFRRyxHQUFSLENBQVksWUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFNQyxxQkFBcUIsTUFBS0MscUJBQUwsQ0FBMkJMLE9BQTNCLENBQTNCO0FBQ0E7QUFDQTtBQUNBLFlBQUlJLHVCQUF1QixLQUEzQixFQUFrQztBQUNoQyxpQkFBTyxDQUFDLEtBQUQsQ0FBUDtBQUNEO0FBVHNCLFlBVWhCRSxJQVZnQixHQVVVRixrQkFWVixDQVVoQkUsSUFWZ0I7QUFBQSxvQ0FVVUYsa0JBVlYsQ0FVVkcsSUFWVTtBQUFBLFlBVVZBLElBVlUseUNBVUgsQ0FBQ1AsT0FBRCxDQVZHO0FBV3ZCOztBQUNBLFlBQU1RLEtBQUssTUFBS0Msd0JBQUwsK0NBQWlDRixJQUFqQyxFQUFYO0FBQ0E7QUFDQTtBQUNBLFlBQU1HLGlCQUFpQixNQUFLQyxpQkFBTCxlQUF1QkgsRUFBdkIsMENBQThCRCxJQUE5QixHQUF2QjtBQUNBLGVBQU8sQ0FBQ0csY0FBRCxFQUFpQkosSUFBakIsRUFBdUJDLElBQXZCLENBQVA7QUFDRCxPQWpCTSxFQWtCTkssTUFsQk0sQ0FrQkMsVUFBQ0YsY0FBRCxFQUFpQkosSUFBakIsRUFBdUJDLElBQXZCLEVBQWdDO0FBQ3RDO0FBQ0EsWUFBSUcsbUJBQW1CLEtBQXZCLEVBQThCO0FBQzVCLGlCQUFPLEtBQVA7QUFDRDtBQUNEO0FBQ0EsZUFBTyxNQUFLRyxjQUFMLGVBQW9CSCxjQUFwQixFQUFvQ0osSUFBcEMsMENBQTZDQyxJQUE3QztBQUNMO0FBREssU0FFSk8sSUFGSSxDQUVDO0FBQUEsaUJBQVksTUFBS0MsY0FBTCxDQUFvQmYsT0FBcEIsRUFBNkJnQixRQUE3QixDQUFaO0FBQUEsU0FGRCxDQUFQO0FBR0QsT0EzQk07QUE0QlA7QUE1Qk8sT0E2Qk5DLEtBN0JNLENBNkJBO0FBQUEsZUFBUyxNQUFLQyxXQUFMLENBQWlCbEIsT0FBakIsRUFBMEJFLEtBQTFCLENBQVQ7QUFBQSxPQTdCQSxDQUFQO0FBOEJEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzswQ0FDc0JGLE8sRUFBUztBQUM3QixhQUFPO0FBQ0xNLGNBQU1OLFFBQVFNLElBRFQ7QUFFTEMsY0FBTSxDQUFDUCxPQUFEO0FBRkQsT0FBUDtBQUlEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzZDQUN5QkEsTyxFQUFTO0FBQ2hDLGFBQU9BLFdBQVdBLFFBQVFRLEVBQTFCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztzQ0FDa0JBLEUsRUFBYTtBQUM3QixVQUFJLEtBQUtULFlBQUwsQ0FBa0JTLEVBQWxCLENBQUosRUFBMkI7QUFDekIsZUFBTyxLQUFLVCxZQUFMLENBQWtCUyxFQUFsQixDQUFQO0FBQ0Q7O0FBSDRCLHdDQUFORCxJQUFNO0FBQU5BLFlBQU07QUFBQTs7QUFJN0IsVUFBTUcsaUJBQWlCLEtBQUtkLG9CQUFMLGNBQTBCWSxFQUExQixTQUFpQ0QsSUFBakMsRUFBdkI7QUFDQSxVQUFJLENBQUNHLGNBQUwsRUFBcUI7QUFDbkIsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxVQUFJQSxlQUFlUyxRQUFuQixFQUE2QjtBQUMzQixhQUFLcEIsWUFBTCxDQUFrQlMsRUFBbEIsSUFBd0JFLGNBQXhCO0FBQ0Q7QUFDRCxhQUFPQSxjQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7bUNBQ2VWLE8sRUFBU2dCLFEsRUFBVTtBQUFBOztBQUNoQyxVQUFJQSxhQUFhLEtBQWpCLEVBQXdCO0FBQ3RCLGVBQU8sS0FBUDtBQUNEO0FBQ0QsVUFBTUksWUFBWSxpQ0FBa0JKLFFBQWxCLEtBQStCLEVBQWpEO0FBQ0EsYUFBTyxtQkFBUUssR0FBUixDQUFZRCxVQUFVRSxHQUFWLENBQWM7QUFBQSxlQUFRLE9BQUtDLFlBQUwsQ0FBa0J2QixPQUFsQixFQUEyQk0sSUFBM0IsQ0FBUjtBQUFBLE9BQWQsQ0FBWixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2dDQUNZTixPLEVBQVNFLEssRUFBTztBQUMxQixVQUFJLEtBQUtMLE9BQVQsRUFBa0I7QUFDaEIsYUFBSzJCLFFBQUwsQ0FBY3RCLE1BQU11QixLQUFwQjtBQUNEO0FBQ0QsYUFBTyxLQUFLRixZQUFMLENBQWtCdkIsT0FBbEIsRUFBMkIsS0FBSzBCLGtCQUFMLENBQXdCeEIsTUFBTUYsT0FBOUIsQ0FBM0IsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztpQ0FDYUEsTyxFQUFTTSxJLEVBQU07QUFDMUIsV0FBS0wsR0FBTCxDQUFTLGNBQVQsRUFBeUJLLElBQXpCO0FBQ0Q7Ozs7O0FBSVksU0FBU2IsU0FBVCxDQUFtQkUsT0FBbkIsRUFBNEI7QUFDekMsU0FBTyxJQUFJRCxHQUFKLENBQVFDLE9BQVIsQ0FBUDtBQUNEIiwiZmlsZSI6ImJvdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9taXNlIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7b3ZlcnJpZGVQcm9wZXJ0aWVzfSBmcm9tICcuL3V0aWwvYm90LWhlbHBlcnMnO1xuaW1wb3J0IHtwcm9jZXNzTWVzc2FnZX0gZnJvbSAnLi91dGlsL3Byb2Nlc3MtbWVzc2FnZSc7XG5pbXBvcnQge25vcm1hbGl6ZVJlc3BvbnNlfSBmcm9tICcuL3V0aWwvcmVzcG9uc2UnO1xuXG5leHBvcnQgY2xhc3MgQm90IHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7Y3JlYXRlTWVzc2FnZUhhbmRsZXIsIHZlcmJvc2V9ID0gb3B0aW9ucztcbiAgICBpZiAoIWNyZWF0ZU1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIFwiY3JlYXRlTWVzc2FnZUhhbmRsZXJcIiBvcHRpb24uJyk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlTWVzc2FnZUhhbmRsZXIgPSBjcmVhdGVNZXNzYWdlSGFuZGxlcjtcbiAgICAvLyBMb2cgbW9yZT9cbiAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgIC8vIENhY2hlIG9mIG1lc3NhZ2UgaGFuZGxlcnMuXG4gICAgdGhpcy5oYW5kbGVyQ2FjaGUgPSB7fTtcbiAgICAvLyBBbGxvdyBhbnkgb2YgdGhlc2Ugb3B0aW9ucyB0byBvdmVycmlkZSBkZWZhdWx0IEJvdCBtZXRob2RzLlxuICAgIG92ZXJyaWRlUHJvcGVydGllcyh0aGlzLCBvcHRpb25zLCBbXG4gICAgICAnZm9ybWF0RXJyb3JNZXNzYWdlJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2xvZ0Vycm9yJyxcbiAgICAgICdvbk1lc3NhZ2UnLFxuICAgICAgJ2lnbm9yZU1lc3NhZ2UnLFxuICAgICAgJ2dldE1lc3NhZ2VIYW5kbGVyQ2FjaGVJZCcsXG4gICAgICAnZ2V0TWVzc2FnZUhhbmRsZXInLFxuICAgICAgJ2dldE1lc3NhZ2VIYW5kbGVyQXJncycsXG4gICAgICAnaGFuZGxlUmVzcG9uc2UnLFxuICAgICAgJ2hhbmRsZUVycm9yJyxcbiAgICAgICdzZW5kUmVzcG9uc2UnLFxuICAgIF0pO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSBwcm9jZXNzTWVzc2FnZSBmdW5jdGlvbiBvbiBCb3QgaW5zdGFuY2VzIGZvciBjb252ZW5pZW5jZS5cbiAgcHJvY2Vzc01lc3NhZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBwcm9jZXNzTWVzc2FnZSguLi5hcmdzKTtcbiAgfVxuXG4gIC8vIFN0cmluZyBmb3JtYXR0aW5nIGhlbHBlciBmdW5jdGlvbnMuXG4gIGZvcm1hdEVycm9yTWVzc2FnZShtZXNzYWdlKSB7IHJldHVybiBgQW4gZXJyb3Igb2NjdXJyZWQ6ICR7bWVzc2FnZX1gOyB9XG5cbiAgLy8gT3ZlcnJpZGFibGUgbG9nZ2VyLlxuICBsb2coLi4uYXJncykge1xuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGFibGUgZXJyb3IgbG9nZ2VyLlxuICBsb2dFcnJvciguLi5hcmdzKSB7XG4gICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgbWFpbiBcInJ1biBsb29wXCIgZm9yIHRoZSBib3QuIFdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkLCBpdCBnZXRzXG4gIC8vIHBhc3NlZCBpbnRvIHRoaXMgZnVuY3Rpb24gdG8gYmUgaGFuZGxlZC5cbiAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gUHJvbWlzZS50cnkoKCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSBtZXNzYWdlIHRleHQgYW5kIGFuIG9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyBiYXNlZCBvbiB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbWVzc2FnZS4gVGhpcyBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIFwibWVzc2FnZVwiIGlzIGFuIG9iamVjdCxcbiAgICAgIC8vIGFuZCBub3QgYSB0ZXh0IHN0cmluZy5cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyQXJncyA9IHRoaXMuZ2V0TWVzc2FnZUhhbmRsZXJBcmdzKG1lc3NhZ2UpO1xuICAgICAgLy8gQWJvcnQgaWYgZmFsc2Ugd2FzIHJldHVybmVkLiBUaGlzIGdpdmVzIHRoZSBnZXRNZXNzYWdlSGFuZGxlckFyZ1xuICAgICAgLy8gZnVuY3Rpb24gdGhlIGFiaWxpdHkgdG8gcHJlLWVtcHRpdmVseSBpZ25vcmUgbWVzc2FnZXMuXG4gICAgICBpZiAobWVzc2FnZUhhbmRsZXJBcmdzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gW2ZhbHNlXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHt0ZXh0LCBhcmdzID0gW21lc3NhZ2VdfSA9IG1lc3NhZ2VIYW5kbGVyQXJncztcbiAgICAgIC8vIEdldCB0aGUgaWQgdG8gcmV0cmlldmUgYSBzdGF0ZWZ1bCBtZXNzYWdlIGhhbmRsZXIgZnJvbSB0aGUgY2FjaGUuXG4gICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TWVzc2FnZUhhbmRsZXJDYWNoZUlkKC4uLmFyZ3MpO1xuICAgICAgLy8gR2V0IGEgY2FjaGVkIG1lc3NhZ2UgaGFuZGxlciB2aWEgaXRzIGlkLCBvciBjYWxsIGNyZWF0ZU1lc3NhZ2VIYW5kbGVyXG4gICAgICAvLyB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSB0aGlzLmdldE1lc3NhZ2VIYW5kbGVyKGlkLCAuLi5hcmdzKTtcbiAgICAgIHJldHVybiBbbWVzc2FnZUhhbmRsZXIsIHRleHQsIGFyZ3NdO1xuICAgIH0pXG4gICAgLnNwcmVhZCgobWVzc2FnZUhhbmRsZXIsIHRleHQsIGFyZ3MpID0+IHtcbiAgICAgIC8vIElmIG1lc3NhZ2VIYW5kbGVyQXJncyBvciBnZXRNZXNzYWdlSGFuZGxlciByZXR1cm5lZCBmYWxzZSwgYWJvcnQuXG4gICAgICBpZiAobWVzc2FnZUhhbmRsZXIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFByb2Nlc3MgdGV4dCBhbmQgYWRkaXRpb25hbCBhcmdzIHRocm91Z2ggdGhlIG1lc3NhZ2UgaGFuZGxlci5cbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2VIYW5kbGVyLCB0ZXh0LCAuLi5hcmdzKVxuICAgICAgICAvLyBUaGVuIGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHRoaXMuaGFuZGxlUmVzcG9uc2UobWVzc2FnZSwgcmVzcG9uc2UpKTtcbiAgICB9KVxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgaGFuZGxlIHRoYXQuXG4gICAgLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRXJyb3IobWVzc2FnZSwgZXJyb3IpKTtcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBtZXNzYWdlIHRleHQgYW5kIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAvLyB0byBiZSBwYXNzZWQgaW50byBtZXNzYWdlIGhhbmRsZXJzIChhbmQgdGhlIGdldE1lc3NhZ2VIYW5kbGVyQ2FjaGVJZCBhbmRcbiAgLy8gZ2V0TWVzc2FnZUhhbmRsZXIgZnVuY3Rpb25zKS5cbiAgLy9cbiAgLy8gVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgXCJtZXNzYWdlXCIgdmFsdWUgcGFzc2VkIGludG8gb25NZXNzYWdlLlxuICAvL1xuICAvLyBCeSBkZWZhdWx0LCBCb3QgZXhwZWN0IFwibWVzc2FnZVwiIHRvIGJlIGFuIG9iamVjdCB3aXRoLCBhdCB0aGUgbWluaW11bSwgYVxuICAvLyBcInRleHRcIiBwcm9wZXJ0eS4gSWYgeW91ciBtZXNzYWdlIGlzIGluIGEgZGlmZmVyZW50IGZvcm1hdCwgb3ZlcnJpZGUgdGhpc1xuICAvLyBmdW5jdGlvbi4gRWcuIElmIG1lc3NhZ2VzIGFyZSBqdXN0IHN0cmluZ3Mgb2YgdGV4dCwgcmV0dXJuIHt0ZXh0OiBtZXNzYWdlfS5cbiAgZ2V0TWVzc2FnZUhhbmRsZXJBcmdzKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogbWVzc2FnZS50ZXh0LFxuICAgICAgYXJnczogW21lc3NhZ2VdLFxuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gYSB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhbiBpZCB0byBjYWNoZSBzdGF0ZWZ1bCBtZXNzYWdlXG4gIC8vIGhhbmRsZXJzIHJldHVybmVkIGZyb20gdGhlIGdldE1lc3NhZ2VIYW5kbGVyIGZ1bmN0aW9uLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBcImFyZ3NcIiByZXR1cm5lZCBmcm9tIGdldE1lc3NhZ2VIYW5kbGVyQXJncy5cbiAgLy9cbiAgLy8gQnkgZGVmYXVsdCwgQm90IGV4cGVjdHMgXCJtZXNzYWdlXCIgdG8gYmUgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiIHByb3BlcnR5LiBJZlxuICAvLyB5b3VyIG1lc3NhZ2UgaXMgaW4gYSBkaWZmZXJlbnQgZm9ybWF0LCBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uLlxuICBnZXRNZXNzYWdlSGFuZGxlckNhY2hlSWQobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlICYmIG1lc3NhZ2UuaWQ7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBtZXNzYWdlIGhhbmRsZXIsIGVpdGhlciBmcm9tIGNhY2hlIChpZiBpdCBleGlzdHMpIG9yIGNyZWF0ZWQgYnlcbiAgLy8gdGhlIGNyZWF0ZU1lc3NhZ2VIYW5kbGVyIGZ1bmN0aW9uLiBJZiB0aGUgbWVzc2FnZSBoYW5kbGVyIGlzIHN0YXRlZnVsIChpZS5cbiAgLy8gaGFzIGEgdHJ1ZSBcImhhc1N0YXRlXCIgcHJvcGVydHkpIHN0b3JlIGl0IGluIHRoZSBjYWNoZSBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBcImFyZ3NcIiByZXR1cm5lZCBmcm9tIGdldE1lc3NhZ2VIYW5kbGVyQXJncy5cbiAgZ2V0TWVzc2FnZUhhbmRsZXIoaWQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyQ2FjaGVbaWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyQ2FjaGVbaWRdO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IHRoaXMuY3JlYXRlTWVzc2FnZUhhbmRsZXIoaWQsIC4uLmFyZ3MpO1xuICAgIGlmICghbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VIYW5kbGVyLmhhc1N0YXRlKSB7XG4gICAgICB0aGlzLmhhbmRsZXJDYWNoZVtpZF0gPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2VIYW5kbGVyO1xuICB9XG5cbiAgLy8gSWYgYSBtZXNzYWdlIGhhbmRsZXIgZGlkbid0IHRocm93IGFuIGV4Y2VwdGlvbiBhbmQgd2Fzbid0IHJlamVjdGVkLCBydW5cbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgLy9cbiAgLy8gVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgb3JpZ2luYWwgXCJtZXNzYWdlXCIgYW5kIFwicmVzcG9uc2VcIiB2YWx1ZSByZXR1cm5lZFxuICAvLyBvciB5aWVsZGVkIGJ5IHRoZSBtZXNzYWdlIGhhbmRsZXIuIE5vcm1hbGl6ZSB0aGUgcmVzcG9uc2UgaW50byBhbiBhcnJheVxuICAvLyBjb250YWluaW5nIHplcm8gb3IgbW9yZSBtZXNzYWdlcywgYW5kIHBhc3MgZWFjaCB0byB0aGUgc2VuZFJlc3BvbnNlIG1ldGhvZCxcbiAgLy8gaW4gb3JkZXIuXG4gIGhhbmRsZVJlc3BvbnNlKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZXMgPSBub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSkgfHwgW107XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3BvbnNlcy5tYXAodGV4dCA9PiB0aGlzLnNlbmRSZXNwb25zZShtZXNzYWdlLCB0ZXh0KSkpO1xuICB9XG5cbiAgLy8gSWYgYSBtZXNzYWdlIGhhbmRsZXIgdGhyZXcgYW4gZXhjZXB0aW9uIG9yIHdhcyBvdGhlcndpc2UgcmVqZWN0ZWQsIHJ1biB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBvcmlnaW5hbCBcIm1lc3NhZ2VcIiBhbmQgZXJyb3Igb2JqZWN0LiBTaG93IHRoZVxuICAvLyBlcnJvciBtZXNzYWdlIGluIHRoZSBzYW1lIGNoYW5uZWwsIGdyb3VwIG9yIERNIGZyb20gd2hpY2ggdGhlIG1lc3NhZ2VcbiAgLy8gb3JpZ2luYXRlZCwgYW5kIG9wdGlvbmFsbHkgbG9nIHRoZSBlcnJvciBzdGFjay5cbiAgaGFuZGxlRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICB0aGlzLmxvZ0Vycm9yKGVycm9yLnN0YWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlc3BvbnNlKG1lc3NhZ2UsIHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlKGVycm9yLm1lc3NhZ2UpKTtcbiAgfVxuXG4gIC8vIE9uY2UgdGhlIHJlc3BvbnNlIChzdWNjZXNzZnVsIG9yIG5vdCkgaGFzIGJlZW4gaGFuZGxlZCwgdGhpcyBtZXNzYWdlIGRvZXNcbiAgLy8gdGhlIGFjdHVhbCBcInNlbmRpbmdcIiBvZiB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgY2hhdCBzZXJ2aWNlLiBXaGljaCBtZWFuc1xuICAvLyBpdCBuZWVkcyB0byBiZSBvdmVycmlkZGVuLiBJZiBub3QsIGl0IHdpbGwganVzdCBsb2cgdG8gdGhlIGNvbnNvbGUuXG4gIC8vXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG9yaWdpbmFsIFwibWVzc2FnZVwiIGFuZCB0aGUgbm9ybWFsaXplZCBtZXNzYWdlXG4gIC8vIG9yIGZvcm1hdHRlZCBlcnJvciBtZXNzYWdlIGFzIHRoZSBcInRleHRcIiB2YWx1ZS5cbiAgLy9cbiAgLy8gSWYgc2VuZGluZyB0aGUgcmVzcG9uc2UgcnVucyBhc3luY2hyb25vdXNseSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFcbiAgLy8gcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHJlc3BvbnNlIGhhcyBiZWVuIHNlbnQuXG4gIHNlbmRSZXNwb25zZShtZXNzYWdlLCB0ZXh0KSB7XG4gICAgdGhpcy5sb2coJ3NlbmRSZXNwb25zZScsIHRleHQpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQm90KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBCb3Qob3B0aW9ucyk7XG59XG4iXX0=

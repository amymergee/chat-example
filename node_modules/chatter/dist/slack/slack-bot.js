'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlackBot = undefined;

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = createSlackBot;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _bot = require('../bot');

var _botHelpers = require('../util/bot-helpers');

var _response = require('../util/response');

var _queue = require('../util/queue');

var _queue2 = _interopRequireDefault(_queue);

var _messageParser = require('./util/message-parser');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SlackBot = exports.SlackBot = function (_Bot) {
  (0, _inherits3.default)(SlackBot, _Bot);

  function SlackBot() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SlackBot);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SlackBot.__proto__ || (0, _getPrototypeOf2.default)(SlackBot)).call(this, options));

    var slack = options.slack,
        getSlack = options.getSlack,
        _options$name = options.name,
        name = _options$name === undefined ? 'Chatter Bot' : _options$name,
        _options$icon = options.icon,
        icon = _options$icon === undefined ? 'https://static.bocoup.com/chatter/logo.png' : _options$icon,
        _options$eventNames = options.eventNames,
        eventNames = _options$eventNames === undefined ? ['open', 'error', 'message'] : _options$eventNames,
        _options$postMessageD = options.postMessageDelay,
        postMessageDelay = _options$postMessageD === undefined ? 250 : _options$postMessageD;

    if (!slack && !getSlack) {
      throw new TypeError('Missing required "slack" or "getSlack" option.');
    }
    // Bot name and icon.
    _this.name = name;
    _this.icon = icon;
    // Either specify a slack object or a function that will be used to get one.
    _this.slack = slack;
    _this.getSlack = getSlack;
    // Slack rtm client event names to bind to.
    _this.eventNames = eventNames;
    // Delay between messages sent via postMessage.
    _this.postMessageDelay = postMessageDelay;
    // Allow any of these options to override default Bot methods.
    (0, _botHelpers.overrideProperties)(_this, options, ['formatOnOpen', 'formatOnError', 'login', 'onOpen', 'onError', 'postMessageOptions', 'postMessageActual']);
    // Create per-channel queues of messages to be sent.
    _this.postMessageQueue = new _queue2.default({
      onDrain: _this.postMessageActual.bind(_this)
    });
    return _this;
  }

  // Provide a bound-to-this-slack wrapper around the parseMessage utility
  // function.


  (0, _createClass3.default)(SlackBot, [{
    key: 'parseMessage',
    value: function parseMessage() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _messageParser.parseMessage.apply(undefined, [this.slack].concat(args));
    }

    // String formatting helper functions.

  }, {
    key: 'formatErrorMessage',
    value: function formatErrorMessage(message) {
      return 'An error occurred: `' + message + '`';
    }
  }, {
    key: 'formatOnOpen',
    value: function formatOnOpen(_ref) {
      var user = _ref.user,
          team = _ref.team;
      return 'Connected to ' + team.name + ' as ' + user.name + '.';
    }
  }, {
    key: 'formatOnError',
    value: function formatOnError(args) {
      return this.name + ' error: ' + (0, _stringify2.default)(args);
    }

    // Return an object that defines the message text and an additional "meta"
    // argument containing a number of relevant properties, to be passed into
    // message handlers (and the getMessageHandlerCacheId and getMessageHandler
    // functions).
    //
    // This function receives a slack "message" object.

  }, {
    key: 'getMessageHandlerArgs',
    value: function getMessageHandlerArgs(message) {
      // Ignore bot messages.
      if (message.subtype === 'bot_message') {
        return false;
      }
      var origMessage = message;
      var channel = this.slack.rtmClient.dataStore.getChannelGroupOrDMById(message.channel);
      // Ignore non-message messages.
      if (message.type !== 'message') {
        return false;
      }
      // If the message was a "changed" message, get the underlying message.
      if (message.subtype === 'message_changed') {
        message = message.message;
      }
      // Ignore any message with a subtype or attachments.
      if (message.subtype || message.attachments) {
        return false;
      }
      var user = this.slack.rtmClient.dataStore.getUserById(message.user);
      var meta = {
        bot: this,
        slack: this.slack,
        message: message,
        origMessage: origMessage,
        channel: channel,
        user: user
      };
      return {
        text: message.text,
        args: [meta]
      };
    }

    // Return a value that will be used as an id to cache stateful message
    // handlers returned from the getMessageHandler function.
    //
    // This function receives the "meta" object from getMessageHandlerArgs. and
    // returns the message.channel property, which is the channel / group / DM id.

  }, {
    key: 'getMessageHandlerCacheId',
    value: function getMessageHandlerCacheId(meta) {
      return meta.message.channel;
    }

    // First, ensure the bot has a "slack" object, then bind event handlers and
    // start the bot.

  }, {
    key: 'login',
    value: function login() {
      if (!this.slack) {
        this.slack = this.getSlack();
        if (!this.slack || (0, _typeof3.default)(this.slack) !== 'object') {
          throw new TypeError('The "getSlack" function must return an object.');
        }
      }
      var slack = this.slack;
      if (!slack.rtmClient) {
        throw new TypeError('The "slack" object is missing a required "rtmClient" property.');
      } else if (!slack.rtmClient.dataStore) {
        throw new TypeError('The "slack" object is missing a required "rtmClient.dataStore" property.');
      } else if (!slack.webClient) {
        throw new TypeError('The "slack" object is missing a required "webClient" property.');
      }
      // Bind event handlers to the slack rtm client.
      this.bindEventHandlers(this.eventNames);
      // Start the rtm client!
      this.slack.rtmClient.start();
      // Make it chainable.
      return this;
    }

    // Bind whitelisted "foo"-type slack rtm events to "onFoo"-type bot methods.

  }, {
    key: 'bindEventHandlers',
    value: function bindEventHandlers(events) {
      var _this2 = this;

      events.forEach(function (name) {
        var method = _this2['on' + name[0].toUpperCase() + name.slice(1)];
        if (method) {
          _this2.slack.rtmClient.on(name, method.bind(_this2));
        }
      });
    }

    // When the slack rtm client connects, log a message.

  }, {
    key: 'onOpen',
    value: function onOpen() {
      var _slack$rtmClient = this.slack.rtmClient,
          dataStore = _slack$rtmClient.dataStore,
          activeUserId = _slack$rtmClient.activeUserId,
          activeTeamId = _slack$rtmClient.activeTeamId;

      var user = dataStore.getUserById(activeUserId);
      var team = dataStore.getTeamById(activeTeamId);
      this.log(this.formatOnOpen({ user: user, team: team }));
    }

    // If a slack error is encountered, log an error.

  }, {
    key: 'onError',
    value: function onError() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.logError(this.formatOnError(args));
    }

    // After a message handler response has been normalized, send the response
    // text to the channel from where the message originated.

  }, {
    key: 'sendResponse',
    value: function sendResponse(message, text) {
      return this._postMessage(message.channel, text);
    }

    // Send an arbitrary message to an arbitrary slack channel, Returns a promise
    // that resolves after all queued messages for the given channelId have been
    // sent.
    // Usage:
    //   postMessage(channelId, message) // message will be normalized and passed into postMessageOptions
    //   postMessage(channelId, options) // options will be used instead of postMessageOptions

  }, {
    key: 'postMessage',
    value: function postMessage(channelId, options) {
      if ((0, _response.isMessage)(options)) {
        options = (0, _response.normalizeResponse)(options)[0];
      }
      return this._postMessage(channelId, options);
    }

    // For use internally. Doesn't call normalizeResponse since Bot#handleResponse
    // and SlackBot#postMessage will have already done that.

  }, {
    key: '_postMessage',
    value: function _postMessage(channelId, options) {
      if (typeof options === 'string') {
        options = this.postMessageOptions(options);
      }
      // Create a per-channelId queue of responses to be sent.
      return this.postMessageQueue.enqueue(channelId, options);
    }

    // Get postMessage options. See the slack API documentation for more info:
    // https://api.slack.com/methods/chat.postMessage

  }, {
    key: 'postMessageOptions',
    value: function postMessageOptions(text) {
      return {
        as_user: false,
        username: this.name,
        icon_url: this.icon,
        text: text,
        unfurl_links: false,
        unfurl_media: false
      };
    }

    // For each response, call the slack web client postMessage API and then
    // pause briefly. This prevents flooding and allows the bot's responses to
    // feel well-paced.

  }, {
    key: 'postMessageActual',
    value: function postMessageActual(channelId, options) {
      var _this3 = this;

      return this.slack.webClient.chat.postMessage(channelId, null, options).then(function () {
        return _bluebird2.default.delay(_this3.postMessageDelay);
      });
    }

    // Get the bot's name and a list of aliases suitable for use in a top-level
    // command message handler. If "isIm" is true, set "name" to null and add
    // the bot name to the list of aliases, so the bot will both respond to the
    // name (or any other aliases) but also to un-prefixed messages.

  }, {
    key: 'getBotNameAndAliases',
    value: function getBotNameAndAliases() {
      var isIm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _slack$rtmClient2 = this.slack.rtmClient,
          activeUserId = _slack$rtmClient2.activeUserId,
          dataStore = _slack$rtmClient2.dataStore;
      // Bot name.

      var name = dataStore.getUserById(activeUserId).name;
      // Aliases for a top-level bot command.
      var aliases = [name + ':', '<@' + activeUserId + '>', '<@' + activeUserId + '>:'];
      if (isIm) {
        aliases.unshift(name);
        name = null;
      }
      return { name: name, aliases: aliases };
    }
  }]);
  return SlackBot;
}(_bot.Bot);

function createSlackBot(options) {
  return new SlackBot(options);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zbGFjay9zbGFjay1ib3QuanMiXSwibmFtZXMiOlsiY3JlYXRlU2xhY2tCb3QiLCJTbGFja0JvdCIsIm9wdGlvbnMiLCJzbGFjayIsImdldFNsYWNrIiwibmFtZSIsImljb24iLCJldmVudE5hbWVzIiwicG9zdE1lc3NhZ2VEZWxheSIsIlR5cGVFcnJvciIsInBvc3RNZXNzYWdlUXVldWUiLCJvbkRyYWluIiwicG9zdE1lc3NhZ2VBY3R1YWwiLCJiaW5kIiwiYXJncyIsIm1lc3NhZ2UiLCJ1c2VyIiwidGVhbSIsInN1YnR5cGUiLCJvcmlnTWVzc2FnZSIsImNoYW5uZWwiLCJydG1DbGllbnQiLCJkYXRhU3RvcmUiLCJnZXRDaGFubmVsR3JvdXBPckRNQnlJZCIsInR5cGUiLCJhdHRhY2htZW50cyIsImdldFVzZXJCeUlkIiwibWV0YSIsImJvdCIsInRleHQiLCJ3ZWJDbGllbnQiLCJiaW5kRXZlbnRIYW5kbGVycyIsInN0YXJ0IiwiZXZlbnRzIiwiZm9yRWFjaCIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJvbiIsImFjdGl2ZVVzZXJJZCIsImFjdGl2ZVRlYW1JZCIsImdldFRlYW1CeUlkIiwibG9nIiwiZm9ybWF0T25PcGVuIiwibG9nRXJyb3IiLCJmb3JtYXRPbkVycm9yIiwiX3Bvc3RNZXNzYWdlIiwiY2hhbm5lbElkIiwicG9zdE1lc3NhZ2VPcHRpb25zIiwiZW5xdWV1ZSIsImFzX3VzZXIiLCJ1c2VybmFtZSIsImljb25fdXJsIiwidW5mdXJsX2xpbmtzIiwidW5mdXJsX21lZGlhIiwiY2hhdCIsInBvc3RNZXNzYWdlIiwidGhlbiIsImRlbGF5IiwiaXNJbSIsImFsaWFzZXMiLCJ1bnNoaWZ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkF1T3dCQSxjOztBQXZPeEI7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0lBRWFDLFEsV0FBQUEsUTs7O0FB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QSxVQUFNdUQsVUFBVSxDQUNYdkQsSUFEVyxlQUVUa0MsWUFGUyxlQUdUQSxZQUhTLFFBQWhCO0FBS0EsVUFBSW9CLElBQUosRUFBVTtBQUNSQyxnQkFBUUMsT0FBUixDQUFnQnhELElBQWhCO0FBQ0FBLGVBQU8sSUFBUDtBQUNEO0FBQ0QsYUFBTyxFQUFDQSxVQUFELEVBQU91RCxnQkFBUCxFQUFQO0FBQ0Q7Ozs7O0FBSVksU0FBUzVELGNBQVQsQ0FBd0JFLE9BQXhCLEVBQWlDO0FBQzlDLFNBQU8sSUFBSUQsUUFBSixDQUFhQyxPQUFiLENBQVA7QUFDRCIsImZpbGUiOiJzbGFjay1ib3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvbWlzZSBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQge0JvdH0gZnJvbSAnLi4vYm90JztcbmltcG9ydCB7b3ZlcnJpZGVQcm9wZXJ0aWVzfSBmcm9tICcuLi91dGlsL2JvdC1oZWxwZXJzJztcbmltcG9ydCB7aXNNZXNzYWdlLCBub3JtYWxpemVSZXNwb25zZX0gZnJvbSAnLi4vdXRpbC9yZXNwb25zZSc7XG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vdXRpbC9xdWV1ZSc7XG5pbXBvcnQge3BhcnNlTWVzc2FnZX0gZnJvbSAnLi91dGlsL21lc3NhZ2UtcGFyc2VyJztcblxuZXhwb3J0IGNsYXNzIFNsYWNrQm90IGV4dGVuZHMgQm90IHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBzbGFjayxcbiAgICAgIGdldFNsYWNrLFxuICAgICAgbmFtZSA9ICdDaGF0dGVyIEJvdCcsXG4gICAgICBpY29uID0gJ2h0dHBzOi8vc3RhdGljLmJvY291cC5jb20vY2hhdHRlci9sb2dvLnBuZycsXG4gICAgICBldmVudE5hbWVzID0gWydvcGVuJywgJ2Vycm9yJywgJ21lc3NhZ2UnXSxcbiAgICAgIHBvc3RNZXNzYWdlRGVsYXkgPSAyNTAsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzbGFjayAmJiAhZ2V0U2xhY2spIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgXCJzbGFja1wiIG9yIFwiZ2V0U2xhY2tcIiBvcHRpb24uJyk7XG4gICAgfVxuICAgIC8vIEJvdCBuYW1lIGFuZCBpY29uLlxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pY29uID0gaWNvbjtcbiAgICAvLyBFaXRoZXIgc3BlY2lmeSBhIHNsYWNrIG9iamVjdCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdldCBvbmUuXG4gICAgdGhpcy5zbGFjayA9IHNsYWNrO1xuICAgIHRoaXMuZ2V0U2xhY2sgPSBnZXRTbGFjaztcbiAgICAvLyBTbGFjayBydG0gY2xpZW50IGV2ZW50IG5hbWVzIHRvIGJpbmQgdG8uXG4gICAgdGhpcy5ldmVudE5hbWVzID0gZXZlbnROYW1lcztcbiAgICAvLyBEZWxheSBiZXR3ZWVuIG1lc3NhZ2VzIHNlbnQgdmlhIHBvc3RNZXNzYWdlLlxuICAgIHRoaXMucG9zdE1lc3NhZ2VEZWxheSA9IHBvc3RNZXNzYWdlRGVsYXk7XG4gICAgLy8gQWxsb3cgYW55IG9mIHRoZXNlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBCb3QgbWV0aG9kcy5cbiAgICBvdmVycmlkZVByb3BlcnRpZXModGhpcywgb3B0aW9ucywgW1xuICAgICAgJ2Zvcm1hdE9uT3BlbicsXG4gICAgICAnZm9ybWF0T25FcnJvcicsXG4gICAgICAnbG9naW4nLFxuICAgICAgJ29uT3BlbicsXG4gICAgICAnb25FcnJvcicsXG4gICAgICAncG9zdE1lc3NhZ2VPcHRpb25zJyxcbiAgICAgICdwb3N0TWVzc2FnZUFjdHVhbCcsXG4gICAgXSk7XG4gICAgLy8gQ3JlYXRlIHBlci1jaGFubmVsIHF1ZXVlcyBvZiBtZXNzYWdlcyB0byBiZSBzZW50LlxuICAgIHRoaXMucG9zdE1lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSh7XG4gICAgICBvbkRyYWluOiB0aGlzLnBvc3RNZXNzYWdlQWN0dWFsLmJpbmQodGhpcyksXG4gICAgfSk7XG4gIH1cblxuICAvLyBQcm92aWRlIGEgYm91bmQtdG8tdGhpcy1zbGFjayB3cmFwcGVyIGFyb3VuZCB0aGUgcGFyc2VNZXNzYWdlIHV0aWxpdHlcbiAgLy8gZnVuY3Rpb24uXG4gIHBhcnNlTWVzc2FnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHBhcnNlTWVzc2FnZSh0aGlzLnNsYWNrLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8vIFN0cmluZyBmb3JtYXR0aW5nIGhlbHBlciBmdW5jdGlvbnMuXG4gIGZvcm1hdEVycm9yTWVzc2FnZShtZXNzYWdlKSB7IHJldHVybiBgQW4gZXJyb3Igb2NjdXJyZWQ6IFxcYCR7bWVzc2FnZX1cXGBgOyB9XG4gIGZvcm1hdE9uT3Blbih7dXNlciwgdGVhbX0pIHsgcmV0dXJuIGBDb25uZWN0ZWQgdG8gJHt0ZWFtLm5hbWV9IGFzICR7dXNlci5uYW1lfS5gOyB9XG4gIGZvcm1hdE9uRXJyb3IoYXJncykgeyByZXR1cm4gYCR7dGhpcy5uYW1lfSBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gOyB9XG5cbiAgLy8gUmV0dXJuIGFuIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIG1lc3NhZ2UgdGV4dCBhbmQgYW4gYWRkaXRpb25hbCBcIm1ldGFcIlxuICAvLyBhcmd1bWVudCBjb250YWluaW5nIGEgbnVtYmVyIG9mIHJlbGV2YW50IHByb3BlcnRpZXMsIHRvIGJlIHBhc3NlZCBpbnRvXG4gIC8vIG1lc3NhZ2UgaGFuZGxlcnMgKGFuZCB0aGUgZ2V0TWVzc2FnZUhhbmRsZXJDYWNoZUlkIGFuZCBnZXRNZXNzYWdlSGFuZGxlclxuICAvLyBmdW5jdGlvbnMpLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGEgc2xhY2sgXCJtZXNzYWdlXCIgb2JqZWN0LlxuICBnZXRNZXNzYWdlSGFuZGxlckFyZ3MobWVzc2FnZSkge1xuICAgIC8vIElnbm9yZSBib3QgbWVzc2FnZXMuXG4gICAgaWYgKG1lc3NhZ2Uuc3VidHlwZSA9PT0gJ2JvdF9tZXNzYWdlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvcmlnTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuc2xhY2sucnRtQ2xpZW50LmRhdGFTdG9yZS5nZXRDaGFubmVsR3JvdXBPckRNQnlJZChtZXNzYWdlLmNoYW5uZWwpO1xuICAgIC8vIElnbm9yZSBub24tbWVzc2FnZSBtZXNzYWdlcy5cbiAgICBpZiAobWVzc2FnZS50eXBlICE9PSAnbWVzc2FnZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG1lc3NhZ2Ugd2FzIGEgXCJjaGFuZ2VkXCIgbWVzc2FnZSwgZ2V0IHRoZSB1bmRlcmx5aW5nIG1lc3NhZ2UuXG4gICAgaWYgKG1lc3NhZ2Uuc3VidHlwZSA9PT0gJ21lc3NhZ2VfY2hhbmdlZCcpIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIElnbm9yZSBhbnkgbWVzc2FnZSB3aXRoIGEgc3VidHlwZSBvciBhdHRhY2htZW50cy5cbiAgICBpZiAobWVzc2FnZS5zdWJ0eXBlIHx8IG1lc3NhZ2UuYXR0YWNobWVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IHRoaXMuc2xhY2sucnRtQ2xpZW50LmRhdGFTdG9yZS5nZXRVc2VyQnlJZChtZXNzYWdlLnVzZXIpO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICBib3Q6IHRoaXMsXG4gICAgICBzbGFjazogdGhpcy5zbGFjayxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcmlnTWVzc2FnZSxcbiAgICAgIGNoYW5uZWwsXG4gICAgICB1c2VyLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IG1lc3NhZ2UudGV4dCxcbiAgICAgIGFyZ3M6IFttZXRhXSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgdmFsdWUgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYW4gaWQgdG8gY2FjaGUgc3RhdGVmdWwgbWVzc2FnZVxuICAvLyBoYW5kbGVycyByZXR1cm5lZCBmcm9tIHRoZSBnZXRNZXNzYWdlSGFuZGxlciBmdW5jdGlvbi5cbiAgLy9cbiAgLy8gVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgXCJtZXRhXCIgb2JqZWN0IGZyb20gZ2V0TWVzc2FnZUhhbmRsZXJBcmdzLiBhbmRcbiAgLy8gcmV0dXJucyB0aGUgbWVzc2FnZS5jaGFubmVsIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgY2hhbm5lbCAvIGdyb3VwIC8gRE0gaWQuXG4gIGdldE1lc3NhZ2VIYW5kbGVyQ2FjaGVJZChtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEubWVzc2FnZS5jaGFubmVsO1xuICB9XG5cbiAgLy8gRmlyc3QsIGVuc3VyZSB0aGUgYm90IGhhcyBhIFwic2xhY2tcIiBvYmplY3QsIHRoZW4gYmluZCBldmVudCBoYW5kbGVycyBhbmRcbiAgLy8gc3RhcnQgdGhlIGJvdC5cbiAgbG9naW4oKSB7XG4gICAgaWYgKCF0aGlzLnNsYWNrKSB7XG4gICAgICB0aGlzLnNsYWNrID0gdGhpcy5nZXRTbGFjaygpO1xuICAgICAgaWYgKCF0aGlzLnNsYWNrIHx8IHR5cGVvZiB0aGlzLnNsYWNrICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJnZXRTbGFja1wiIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2xhY2sgPSB0aGlzLnNsYWNrO1xuICAgIGlmICghc2xhY2sucnRtQ2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzbGFja1wiIG9iamVjdCBpcyBtaXNzaW5nIGEgcmVxdWlyZWQgXCJydG1DbGllbnRcIiBwcm9wZXJ0eS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsYWNrLnJ0bUNsaWVudC5kYXRhU3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInNsYWNrXCIgb2JqZWN0IGlzIG1pc3NpbmcgYSByZXF1aXJlZCBcInJ0bUNsaWVudC5kYXRhU3RvcmVcIiBwcm9wZXJ0eS4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsYWNrLndlYkNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic2xhY2tcIiBvYmplY3QgaXMgbWlzc2luZyBhIHJlcXVpcmVkIFwid2ViQ2xpZW50XCIgcHJvcGVydHkuJyk7XG4gICAgfVxuICAgIC8vIEJpbmQgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHNsYWNrIHJ0bSBjbGllbnQuXG4gICAgdGhpcy5iaW5kRXZlbnRIYW5kbGVycyh0aGlzLmV2ZW50TmFtZXMpO1xuICAgIC8vIFN0YXJ0IHRoZSBydG0gY2xpZW50IVxuICAgIHRoaXMuc2xhY2sucnRtQ2xpZW50LnN0YXJ0KCk7XG4gICAgLy8gTWFrZSBpdCBjaGFpbmFibGUuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBCaW5kIHdoaXRlbGlzdGVkIFwiZm9vXCItdHlwZSBzbGFjayBydG0gZXZlbnRzIHRvIFwib25Gb29cIi10eXBlIGJvdCBtZXRob2RzLlxuICBiaW5kRXZlbnRIYW5kbGVycyhldmVudHMpIHtcbiAgICBldmVudHMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXNbYG9uJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnNsaWNlKDEpfWBdO1xuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICB0aGlzLnNsYWNrLnJ0bUNsaWVudC5vbihuYW1lLCBtZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzbGFjayBydG0gY2xpZW50IGNvbm5lY3RzLCBsb2cgYSBtZXNzYWdlLlxuICBvbk9wZW4oKSB7XG4gICAgY29uc3Qge2RhdGFTdG9yZSwgYWN0aXZlVXNlcklkLCBhY3RpdmVUZWFtSWR9ID0gdGhpcy5zbGFjay5ydG1DbGllbnQ7XG4gICAgY29uc3QgdXNlciA9IGRhdGFTdG9yZS5nZXRVc2VyQnlJZChhY3RpdmVVc2VySWQpO1xuICAgIGNvbnN0IHRlYW0gPSBkYXRhU3RvcmUuZ2V0VGVhbUJ5SWQoYWN0aXZlVGVhbUlkKTtcbiAgICB0aGlzLmxvZyh0aGlzLmZvcm1hdE9uT3Blbih7dXNlciwgdGVhbX0pKTtcbiAgfVxuXG4gIC8vIElmIGEgc2xhY2sgZXJyb3IgaXMgZW5jb3VudGVyZWQsIGxvZyBhbiBlcnJvci5cbiAgb25FcnJvciguLi5hcmdzKSB7XG4gICAgdGhpcy5sb2dFcnJvcih0aGlzLmZvcm1hdE9uRXJyb3IoYXJncykpO1xuICB9XG5cbiAgLy8gQWZ0ZXIgYSBtZXNzYWdlIGhhbmRsZXIgcmVzcG9uc2UgaGFzIGJlZW4gbm9ybWFsaXplZCwgc2VuZCB0aGUgcmVzcG9uc2VcbiAgLy8gdGV4dCB0byB0aGUgY2hhbm5lbCBmcm9tIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZWQuXG4gIHNlbmRSZXNwb25zZShtZXNzYWdlLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RNZXNzYWdlKG1lc3NhZ2UuY2hhbm5lbCwgdGV4dCk7XG4gIH1cblxuICAvLyBTZW5kIGFuIGFyYml0cmFyeSBtZXNzYWdlIHRvIGFuIGFyYml0cmFyeSBzbGFjayBjaGFubmVsLCBSZXR1cm5zIGEgcHJvbWlzZVxuICAvLyB0aGF0IHJlc29sdmVzIGFmdGVyIGFsbCBxdWV1ZWQgbWVzc2FnZXMgZm9yIHRoZSBnaXZlbiBjaGFubmVsSWQgaGF2ZSBiZWVuXG4gIC8vIHNlbnQuXG4gIC8vIFVzYWdlOlxuICAvLyAgIHBvc3RNZXNzYWdlKGNoYW5uZWxJZCwgbWVzc2FnZSkgLy8gbWVzc2FnZSB3aWxsIGJlIG5vcm1hbGl6ZWQgYW5kIHBhc3NlZCBpbnRvIHBvc3RNZXNzYWdlT3B0aW9uc1xuICAvLyAgIHBvc3RNZXNzYWdlKGNoYW5uZWxJZCwgb3B0aW9ucykgLy8gb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBwb3N0TWVzc2FnZU9wdGlvbnNcbiAgcG9zdE1lc3NhZ2UoY2hhbm5lbElkLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzTWVzc2FnZShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IG5vcm1hbGl6ZVJlc3BvbnNlKG9wdGlvbnMpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9zdE1lc3NhZ2UoY2hhbm5lbElkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEZvciB1c2UgaW50ZXJuYWxseS4gRG9lc24ndCBjYWxsIG5vcm1hbGl6ZVJlc3BvbnNlIHNpbmNlIEJvdCNoYW5kbGVSZXNwb25zZVxuICAvLyBhbmQgU2xhY2tCb3QjcG9zdE1lc3NhZ2Ugd2lsbCBoYXZlIGFscmVhZHkgZG9uZSB0aGF0LlxuICBfcG9zdE1lc3NhZ2UoY2hhbm5lbElkLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHRoaXMucG9zdE1lc3NhZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBwZXItY2hhbm5lbElkIHF1ZXVlIG9mIHJlc3BvbnNlcyB0byBiZSBzZW50LlxuICAgIHJldHVybiB0aGlzLnBvc3RNZXNzYWdlUXVldWUuZW5xdWV1ZShjaGFubmVsSWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gR2V0IHBvc3RNZXNzYWdlIG9wdGlvbnMuIFNlZSB0aGUgc2xhY2sgQVBJIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mbzpcbiAgLy8gaHR0cHM6Ly9hcGkuc2xhY2suY29tL21ldGhvZHMvY2hhdC5wb3N0TWVzc2FnZVxuICBwb3N0TWVzc2FnZU9wdGlvbnModGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICBhc191c2VyOiBmYWxzZSxcbiAgICAgIHVzZXJuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBpY29uX3VybDogdGhpcy5pY29uLFxuICAgICAgdGV4dCxcbiAgICAgIHVuZnVybF9saW5rczogZmFsc2UsXG4gICAgICB1bmZ1cmxfbWVkaWE6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvLyBGb3IgZWFjaCByZXNwb25zZSwgY2FsbCB0aGUgc2xhY2sgd2ViIGNsaWVudCBwb3N0TWVzc2FnZSBBUEkgYW5kIHRoZW5cbiAgLy8gcGF1c2UgYnJpZWZseS4gVGhpcyBwcmV2ZW50cyBmbG9vZGluZyBhbmQgYWxsb3dzIHRoZSBib3QncyByZXNwb25zZXMgdG9cbiAgLy8gZmVlbCB3ZWxsLXBhY2VkLlxuICBwb3N0TWVzc2FnZUFjdHVhbChjaGFubmVsSWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zbGFjay53ZWJDbGllbnQuY2hhdC5wb3N0TWVzc2FnZShjaGFubmVsSWQsIG51bGwsIG9wdGlvbnMpXG4gICAgICAudGhlbigoKSA9PiBQcm9taXNlLmRlbGF5KHRoaXMucG9zdE1lc3NhZ2VEZWxheSkpO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBib3QncyBuYW1lIGFuZCBhIGxpc3Qgb2YgYWxpYXNlcyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgdG9wLWxldmVsXG4gIC8vIGNvbW1hbmQgbWVzc2FnZSBoYW5kbGVyLiBJZiBcImlzSW1cIiBpcyB0cnVlLCBzZXQgXCJuYW1lXCIgdG8gbnVsbCBhbmQgYWRkXG4gIC8vIHRoZSBib3QgbmFtZSB0byB0aGUgbGlzdCBvZiBhbGlhc2VzLCBzbyB0aGUgYm90IHdpbGwgYm90aCByZXNwb25kIHRvIHRoZVxuICAvLyBuYW1lIChvciBhbnkgb3RoZXIgYWxpYXNlcykgYnV0IGFsc28gdG8gdW4tcHJlZml4ZWQgbWVzc2FnZXMuXG4gIGdldEJvdE5hbWVBbmRBbGlhc2VzKGlzSW0gPSBmYWxzZSkge1xuICAgIGNvbnN0IHthY3RpdmVVc2VySWQsIGRhdGFTdG9yZX0gPSB0aGlzLnNsYWNrLnJ0bUNsaWVudDtcbiAgICAvLyBCb3QgbmFtZS5cbiAgICBsZXQgbmFtZSA9IGRhdGFTdG9yZS5nZXRVc2VyQnlJZChhY3RpdmVVc2VySWQpLm5hbWU7XG4gICAgLy8gQWxpYXNlcyBmb3IgYSB0b3AtbGV2ZWwgYm90IGNvbW1hbmQuXG4gICAgY29uc3QgYWxpYXNlcyA9IFtcbiAgICAgIGAke25hbWV9OmAsXG4gICAgICBgPEAke2FjdGl2ZVVzZXJJZH0+YCxcbiAgICAgIGA8QCR7YWN0aXZlVXNlcklkfT46YCxcbiAgICBdO1xuICAgIGlmIChpc0ltKSB7XG4gICAgICBhbGlhc2VzLnVuc2hpZnQobmFtZSk7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtuYW1lLCBhbGlhc2VzfTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNsYWNrQm90KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTbGFja0JvdChvcHRpb25zKTtcbn1cbiJdfQ==
